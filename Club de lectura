###########################################################################
#------------------Club de Lectura-----------------------
#R para Ciencia de Datos (Wickham y Grolemund)
#R-Ladies Barranquilla, Galapagos, Guayaquil y Milagro

#Sesion 13: Capitulo 24 y 25 (Construccion de modelos y muchos modelos)
#Script por: Mercedes Soledispa, Naomy Vera y Julissa Magallanes (R-Ladies Milagro)
###########################################################################

##________________Instalar paquetes________________
install.packages("tidyverse")
install.packages("modelr")
install.packages("datos")
install.packages("hexbin")

##________________Cargar paquetes________________
library(tidyverse)
#Tidyverse es un paquete que contiene varios paquetes.
library(modelr)
#Modelr proporciona funciones que ayudan a crear tuberías elegantes al modelar.
library(datos)
#Datos posee como su nombre lo dice, un conjunto de datos. 
library(hexbin)
#Agrupa y traza agrupaciones hexagonales.

#---------------Ejercicio 1: Diamantes------------
####Relacinado corte y precio 
ggplot(diamantes, aes(corte, precio)) + geom_boxplot()
####Relacionando color y precio
ggplot(diamantes, aes(color, precio)) + geom_boxplot()
#El peor diamante es J (amarillo claro)
####Relacionando Claridad y precio
ggplot(diamantes, aes(claridad, precio)) + geom_boxplot()
#La peor claridad es I1

#__________Cargar paquete de Pokémon________
#install_packages("readr")
pokemon <- readr::read_csv("https://raw.githubusercontent.com/cienciadedatos/datos-de-miercoles/master/datos/2019/2019-07-10/pokemon.csv")

#---------------Ejercicio 2: Pokemon------------
#Relaciondo tipo_1 con velocidad
ggplot(pokemon, aes(tipo_1, velocidad)) + geom_boxplot()
#Relaciondo tipo_2 con defensa
ggplot(pokemon, aes(tipo_2, defensa)) + geom_boxplot()

###----------Ejercicio 3: Pokémon----------
#Relaciondo tipo_1 con velocidad
ggplot(pokemon, aes(tipo_1, velocidad))+geom_hex(bins = 50)
#Relaciondo tipo_2 con defensa
ggplot(pokemon, aes(tipo_2, defensa))+geom_hex(bins = 50)

###-----------Precio y quilates-----------###
ggplot(diamantes, aes(quilate, precio)) + geom_hex(bins = 50, color="purple")

###------------Un modelo mas sencillo------------###
diamantes2 <- diamantes %>%  filter(quilate <= 2.5) %>% 
  mutate(log_precio = log2(precio), log_quilates = log2(quilate))
#diamantes 2 abarcara todos los diamantes de menores o iguales a 2.5 quilates

####------- Nueva relación entre quilates y precio-------
ggplot(diamantes2, aes(log_quilates, log_precio)) + 
  geom_hex(bins = 50,color="purple" )

###---------Ajustando el modelo----------
mod_diamantes <- lm(log_precio ~ log_quilates, data = diamantes2)

cuadricula <- diamantes2 %>% 
  data_grid(quilate = seq_range(quilate, 20)) %>% 
  mutate(log_quilates = log2(quilate)) %>% 
  add_predictions(mod_diamantes, "log_precio") %>% 
  mutate(precio = 2 ^ log_precio)

ggplot(diamantes2, aes(quilate, precio)) + 
  geom_hex(bins = 50) + 
  geom_line(data = cuadricula, colour = "green", size = 2)

###----------Analizando residuos-----------
diamantes2 <- diamantes2 %>% add_residuals(mod_diamantes, "lresid")

ggplot(diamantes2, aes(log_quilates, lresid)) + geom_hex(bins = 50, colour="purple")

###--------Residuos por precio---------
#Relaciondo corte y residuo
ggplot(diamantes2, aes(corte, lresid)) + geom_boxplot(colour="green")
#Relaciondo color y residuo
ggplot(diamantes2, aes(color, lresid)) + geom_boxplot(colour="pink")
#El peor diamante es J (amarillo claro)
#Relacionando claridad y residuo
ggplot(diamantes2, aes(claridad, lresid)) + geom_boxplot(colour="orange")
#La peor claridad es I1

# En este caso trabajaremos a través de un proceso similar para un conjunto de datos diferente

# Llamando bibliotecas
library(tidyverse)
library(modelr)
library(lubridate)
library(datos)

# El conjunto de datos con el que se trabaja es: 
### `gapminder_es`
|Variable       |Clase               |Descripción |
  |:--------------|:-------------------|:-----------|
  |pais           |factor              |Países incluidos en esta selección de datos (142 niveles) |
  |continente      |factor            |Continente en que se encuentra el país (5 niveles) |
  |anio        |entero            |Desde 1952 a 2007. Datos cada 5 años |
  |esperanza_de_vida | numérica | Esperanza de vida al nacer, en años |
  |poblacion | entero | Población
|pib_per_capita | numérica | PIB per cápita (en dólares estadounidenses, ajustados según inflación)

# Cargamos la data
gapminder <- readr::read_csv("https://raw.githubusercontent.com/cienciadedatos/datos-de-miercoles/master/datos/2019/2019-04-24/gapminder_es.csv")

# Seleccionamos un conjunto de datos utilizando la función de filter
# La función filter nos permite filtrar filas según una condición
ECU <- filter(paises, pais == "Ecuador")

# Utilizamos el paquete ggplot2 que incluye algunas funciones como:
# geom_line, geom_boxplot, etc.
# Planteamos un gráfico sencillo con ggplot, usamos la función geom_line para hacer un gráfico de lineas
# Planteamos la evolución del pib_per_capita a través de los años en el Ecuador
ECU %>%
  ggplot(aes(anio, pib_per_capita)) +
  geom_line(size=1, colour="red")

# Para crear gráficos de cajas o boxplot utilizamos geom_boxplot. 
# Este gráfico permite conocer rápidamente tanto la dispersión, como la asimetría, 
# el centro y los datos atípicos de una variable. 
ggplot(ECU, aes(anio, pib_per_capita)) + 
  geom_boxplot()

###---------Ajustando el modelo----------
mod1 <- lm(pib_per_capita ~ anio , data = ECU)

#Infomarcion sobre el modelo resumen 
summary(mod1)

# Utilizando el modelo formamos una cuadricula con la funcion data_grid
# data_grid permite generar una cuadrícula de datos
# add_predictions permite agregar predicciones a un marco de datos, utilizando el modelo
cuadricula1 <- ECU %>% 
  data_grid(anio) %>% 
  add_predictions(mod, "pib_per_capita")

# Formamos una caja de bigotes con las variables de análisis
ggplot(ECU, aes(x= anio, y=pib_per_capita)) + 
  geom_boxplot() +
  geom_point(data = cuadricula1, colour = "red", size = 1)

ggplot(ECU, aes(x= anio, y=pib_per_capita)) + 
  geom_point(data = cuadricula1, colour = "purple", size = 2)

# A continuación calculamos y visualizamos los residuos:
ECU <- ECU %>% 
  add_residuals(mod1)
ECU %>% 
  ggplot(aes(anio, resid)) + 
  geom_ref_line(h = 0, colour="blue", size = 1) + 
  geom_line(colour="red", size = 1)

### Capítulo 25 del libro R "Ciencia de datos". Tema: construcción de muchos modelos.
# "se aprende como crear modelos con facilidad"
*usar modelos simples para comprensión de datos
*uso de columnas de lista para almacenar datos
*construcción de modelos lineales 
*con el paquete 'broom' convertimos modelos de datos ordenados 
# Al instalar el paquete 'tidyverse' tendríamos el paquete broom instalado
library(modelr)
library(tidyverse)
library(datos)
library(gapminder)
# gapminder: es un paquete que se utiliza para seleccionar datos #

gapminder <- readr::read_csv("https://raw.githubusercontent.com/cienciadedatos/datos-de-miercoles/master/datos/2019/2019-04-24/gapminder_es.csv")
gapminder %>% 
 ggplot(aes(anio, esperanza_de_vida, group = pais)) +
 geom_line(alpha = 1/3)
# geom_line conecta en orden la variable del eje x

# Al utilizar filter, se hace un filtro por país en este caso elegimos Ecuador #
# ggtitle se utiliza para nombrar el gráfico #

ecu<- filter(gapminder, pais == "Ecuador")
ecu %>% 
 ggplot(aes(anio, esperanza_de_vida)) + 
 geom_line(size=3, colour="green") + 
 ggtitle("Full data = ")

#esta línea de código se añade las predicciones en este caso Ecuador#
ecu_mod <- lm(esperanza_de_vida ~ anio, data = ecu)
ecu %>% 
 add_predictions(ecu_mod) %>%
 ggplot(aes(anio, pred)) + 
 geom_line(size=2, colour="blue") + 
 ggtitle("Linear trend + ")

#esta línea de código se añade el residual, y remaining pattern#
#remaining pattern divide el plano entre lo positivo y lo negativo#
ecu %>% 
  add_residuals(ecu_mod) %>% 
  ggplot(aes(anio, resid)) + 
  geom_hline(yintercept = 0, colour = "red", size = 1) + 
  geom_line() + 
  ggtitle("Remaining pattern")
 
#---------------DATOS ANIDADOS------------
# Para crear un marco de datos anidados se comienza con datos agrupados 'se anida'#
por_pais <- gapminder %>% 
 group_by(pais, continente) %>% 
 nest()

por_pais$data[[1]]

# Planteamos un modelo
modelo_pais <- function(df) {
  lm(esperanza_de_vida ~ anio, data = df)
}
modelos <- map(por_pais$data, modelo_pais)


por_pais <- por_pais %>%
mutate(modelo = map(data, modelo_pais)) 

#filtramos un conjunto de datos por continente#
por_pais %>%
filter(continente == "Americas")

#---------------DESANIDANDO DATOS------------
#Primero agrupamos pais por pais, creando una data de 142 observaciones con 5 variables#
por_pais <- por_pais %>%
  mutate(
  residuos = map2(data, modelo, add_residuals))

residuos <- unnest(por_pais, residuos)
  
    residuos %>%
     ggplot(aes(anio, resid)) +
     geom_line(aes(group = pais), alpha = 1 / 3) +
     geom_smooth(se = FALSE)

# facet_wrap se lo utiliza para realizar el desanidado por continente#
residuos %>%
      ggplot(aes(anio, resid, group = pais)) +
      geom_line(alpha = 1 / 3) +
      facet_wrap(~continente)
